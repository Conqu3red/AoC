# Code @generated by parsergen; do not edit!
from parsergen.parser_utils import GeneratedParser, TokenStream, Node, Filler
from parsergen.parser_utils import memoize, memoize_left_rec
from functools import reduce

import part2

class P2Parser(part2.P2Base):
    @memoize
    def line(self):
        pos = self.mark()
        """
        c=chunk+ EOF { c };
        """
        parts = []
        for _ in range(1):
            part = self._loop_0()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('EOF')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            c = parts[0]
            return c
        self.goto(pos)
        
        return None
        
    def _loop_0(self):
        """
        chunk+
        """
        children = []
        while True:
            pos = self.mark()
            part = self.chunk()
            if self.match(part): children.append(part)
            else:
                if len(children) == 0:
                    self.fail()
                self.goto(pos)
                break
        return children if len(children) > 0 else None
    @memoize
    def chunk(self):
        pos = self.mark()
        """
        c=bracket | square | curly | angle { c };
        """
        parts = []
        for _ in range(1):
            part = self._or_1()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            c = parts[0]
            return c
        self.goto(pos)
        
        return None
        
    def _or_1(self):
        """
        bracket | square | curly | angle
        """
        pos = self.mark()
        part = self.bracket()
        if self.match(part): return part
        self.goto(pos)
        part = self.square()
        if self.match(part): return part
        self.goto(pos)
        part = self.curly()
        if self.match(part): return part
        self.goto(pos)
        part = self.angle()
        if self.match(part): return part
        self.goto(pos)
        self.fail()
        return None
    @memoize
    def bracket(self):
        pos = self.mark()
        """
        LB chunk* EOF { self.inc_score(")") };
        """
        parts = []
        for _ in range(1):
            part = self.expect('LB')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_2()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('EOF')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            return self.inc_score(")")
        self.goto(pos)
        
        """
        LB chunk* RB;
        """
        parts = []
        for _ in range(1):
            part = self.expect('LB')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_3()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('RB')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            return Node('bracket', parts)
        self.goto(pos)
        
        return None
        
    def _loop_2(self):
        """
        chunk*
        """
        children = []
        while True:
            pos = self.mark()
            part = self.chunk()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    def _loop_3(self):
        """
        chunk*
        """
        children = []
        while True:
            pos = self.mark()
            part = self.chunk()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    @memoize
    def square(self):
        pos = self.mark()
        """
        LS chunk* EOF { self.inc_score("]") };
        """
        parts = []
        for _ in range(1):
            part = self.expect('LS')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_4()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('EOF')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            return self.inc_score("]")
        self.goto(pos)
        
        """
        LS chunk* RS;
        """
        parts = []
        for _ in range(1):
            part = self.expect('LS')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_5()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('RS')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            return Node('square', parts)
        self.goto(pos)
        
        return None
        
    def _loop_4(self):
        """
        chunk*
        """
        children = []
        while True:
            pos = self.mark()
            part = self.chunk()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    def _loop_5(self):
        """
        chunk*
        """
        children = []
        while True:
            pos = self.mark()
            part = self.chunk()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    @memoize
    def curly(self):
        pos = self.mark()
        """
        LC chunk* EOF { self.inc_score("}") };
        """
        parts = []
        for _ in range(1):
            part = self.expect('LC')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_6()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('EOF')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            return self.inc_score("}")
        self.goto(pos)
        
        """
        LC chunk* RC;
        """
        parts = []
        for _ in range(1):
            part = self.expect('LC')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_7()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('RC')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            return Node('curly', parts)
        self.goto(pos)
        
        return None
        
    def _loop_6(self):
        """
        chunk*
        """
        children = []
        while True:
            pos = self.mark()
            part = self.chunk()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    def _loop_7(self):
        """
        chunk*
        """
        children = []
        while True:
            pos = self.mark()
            part = self.chunk()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    @memoize
    def angle(self):
        pos = self.mark()
        """
        LA chunk* EOF { self.inc_score(">") };
        """
        parts = []
        for _ in range(1):
            part = self.expect('LA')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_8()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('EOF')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            return self.inc_score(">")
        self.goto(pos)
        
        """
        LA chunk* RA;
        """
        parts = []
        for _ in range(1):
            part = self.expect('LA')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_9()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('RA')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            return Node('angle', parts)
        self.goto(pos)
        
        return None
        
    def _loop_8(self):
        """
        chunk*
        """
        children = []
        while True:
            pos = self.mark()
            part = self.chunk()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    def _loop_9(self):
        """
        chunk*
        """
        children = []
        while True:
            pos = self.mark()
            part = self.chunk()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
